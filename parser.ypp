%{
	#include "Contracts.hpp"
	#include "Utils.hpp"
	#include "output.hpp"
	#include "SymbolTable.h"
	#include <iostream>
	#include <stdlib.h>

	using namespace std;

	extern int yylex();
	int yyerror(char * message);
	void conditionalOpenScope(SSTYPE value);
	extern int yylineno;
	SymbolTable* symbolTable;
	int whileCounter;
	bool isWhileOrIfIntact;
	bool isWhileOrIfScopeOpened;
%}

%token VOID INT BYTE B BOOL TRUE FALSE RETURN IF WHILE SWITCH CASE BREAK COLON SC COMMA LPAREN LBRACE RBRACE ID NUM STRING

%nonassoc RPAREN /* solving dangling-else problem */
%nonassoc ELSE /* solving dangling-else problem */

%right ASSIGN
%left OR
%left AND
%left RELOP
%left BINOP
%right NOT

%%

Program	: Funcs
          {
            symbolTable->EndProg();
          }
	;

Funcs : FuncDecl Funcs
        {

        } | /*epsilon*/
	;

FuncDecl : RetType ID LPAREN Formals RPAREN LBRACE M Statements RBRACE
           {
                SymbolTableResult res = symbolTable->AddFunc($2.varName,$1.type,$4.formals);
                if(res == FAIL)
                {
                    output::errorDef(yylineno,$2.varName.c_str());
                    exit(0);
                }
                symbolTable->EndProg();
           }
    ;

RetType : Type {$$.type = $1.type;} | VOID { $$.type = _VOID;}
    ;

Formals : FormalsList
          {
            $$.formals = $1.formals;
          } | /*epsilon*/
    ;

FormalsList : FormalDecl
              {
                $$.formals = $1.formals;
              } |
              FormalDecl COMMA FormalsList
              {
                $$.formals = $1.formals;
              }

    ;

FormalDecl : Type ID
             {
                $$.formals.insert(std::pair<varType,std::string>($1.type,$2.varName));
             }
    ;

Statements : Statement {$$.type = $1.type;} | Statements Statement {$$.type = $2.type;}
    ;

Statement : LBRACE M Statements RBRACE {symbolTable->EndProg();} |
            N Type ID SC
            {
                if(!symbolTable->AddVar($3.varName,$2.type))
                {
                    output::errorDef(yylineno,$3.varName.c_str());
                    exit(0);
                }
            } |
            N Type ID ASSIGN Exp SC
            {
                if(!symbolTable->AddVar($3.varName,$2.type))
                {
                    output::errorDef(yylineno,$3.varName.c_str());
                    exit(0);
                }
                if(!areEqualTypes($2,$5));
                {
                    output::errorMismatch(yylineno);
                    exit(0);
                }
            } |
            ID ASSIGN Exp SC
            {
                varType t;
                if(!symbolTable->GetVar($1.varName,t))
                {
                    output::errorUndef(yylineno,$1.varName.c_str());
                    exit(0);
                }
                if(isByte(t) && isNumeric($3) && $3.numVal > MAXBYTE)
                {
                    char* str = toString($3.numVal); //TODO: try to find a better inToString
                    output::errorByteTooLarge(yylineno,str);
                    free(str); //TODO: i'm crying
                    exit(0);
                }
                if(t == $3.type || (t == _INT && $3.type == _BYTE))
                    $$.type = t;
                else
                {
                    output::errorMismatch(yylineno);
                    exit(0);
                }
            } |
            Call SC |
            RETURN SC {$$.type = _VOID;} |
            RETURN Exp SC {$$.type = $2.type;} |
            IF LPAREN Exp RPAREN Statement
            {
                if(!isBoolean($3))
                {
                    output::errorMismatch(yylineno);
                    exit(0);
                }
            } |
            IF LPAREN Exp RPAREN K Statement ELSE K Statement
            {
                if(!isBoolean($3))
                {
                    output::errorMismatch(yylineno);
                    exit(0);
                }
                if(isWhileOrIfScopeOpened)
                {
                    symbolTable->EndProg();
                    isWhileOrIfScopeOpened = false;
                }
            } |
            WHILE LPAREN Exp RPAREN W Statement
            {
                if(!isBoolean($3))
                {
                    output::errorMismatch(yylineno);
                    exit(0);
                }
                whileCounter--;
                if(isWhileOrIfScopeOpened)
                {
                    symbolTable->EndProg();
                    isWhileOrIfScopeOpened = false;
                }
            } |
            BREAK SC
            {
                if(whileCounter <= 0)
                {
                    output::errorUnexpectedBreak(yylineno);
                    exit(0);
                }
            } |
            SWITCH LPAREN Exp RPAREN LBRACE CaseList RBRACE SC
            {
                if(!isNumeric($3))
                {
                    output::errorMismatch(yylineno);
                    exit(0);
                }
            }
    ;

CaseList : CaseStat CaseList | CaseStat
    ;

CaseStat : CASE NUM COLON Statement BREAK SC |
           CASE NUM B COLON Statement BREAK SC
    ;

Call : ID LPAREN ExpList RPAREN
        {
            if($1.varName == LIBPRINT)
            {
                if(!($3.expTypes.size() == 1) || !($3.type == _STRING))
                {
                    std::vector<const char*> stringVec;
                    stringVec.push_back("string");
                    output::errorPrototypeMismatch(yylineno,LIBPRINT,stringVec);
                    exit(0);
                }
                $$.type = _VOID;
            }
            else if($1.varName == LIBPRINTI)
            {
                if(!($3.expTypes.size() == 1) || !isNumeric($3))
                {
                    std::vector<const char*> intVec;
                    intVec.push_back("int");
                    output::errorPrototypeMismatch(yylineno,LIBPRINT,intVec);
                    exit(0);
                }
                $$.type = _VOID;
            }
            else
            {
                vector<varType> expected;
                varType retType;
                SymbolTableResult res = symbolTable->CallFunc($1.varName,$3.expTypes,retType,expected);
                if(res == PROTOTYPE_MISMATCH)
                {
                    output::errorPrototypeMismatch(yylineno,$1.varName.c_str(),getTypeNames(expected));
                    exit(0);
                }
                if(res == NOT_DEFINED)
                {
                    output::errorUndef(yylineno,$1.varName.c_str());
                    exit(0);
                }
                $$.type = retType;
            }
        } |
        ID LPAREN RPAREN
        {
            vector<varType> voidVec;
            vector<varType> expected;
            varType retType;
            SymbolTableResult res = symbolTable->CallFunc($1.varName,voidVec,retType,expected);
            if(res == PROTOTYPE_MISMATCH)
            {
                output::errorPrototypeMismatch(yylineno,$1.varName.c_str(),getTypeNames(expected));
                exit(0);
            }
            if(res == NOT_DEFINED)
            {
                output::errorUndef(yylineno,$1.varName.c_str());
                exit(0);
            }
            $$.type = $1.type;
        }
    ;

ExpList : Exp
          {
            $$.type = $1.type;
            $$.expTypes.push_back($1.type);
          } |
          Exp COMMA ExpList
          {
            $$.expTypes.push_back($1.type);
          }
    ;

Type : INT {$$.type = _INT;} | BYTE {$$.type = _BYTE;} | BOOL {$$.type = _BOOL;}
    ;

Exp : LPAREN Exp RPAREN {$$.type = $2.type;} |
      ID
      {
        $$.type = $1.type;
        $$.varName = $1.varName;
      } |
      Call {$$.type = $1.type;} |
      NUM {$$.type = _INT; $$.numVal = $1.numVal;} |
      NUM B {$$.type = _BYTE; $$.numVal = $1.numVal;} |
      STRING {$$.type = _STRING; $$.stringVal = $1.stringVal;} |
      TRUE {$$.type = _BOOL; $$.boolVal = $1.boolVal;} |
      FALSE {$$.type = _BOOL; $$.boolVal = $1.boolVal;} |
      NOT Exp
      {
            if(!isBoolean($1))
            {
                output::errorMismatch(yylineno);
                exit(0);
            }
            $$.type = $1.type;
            $$.boolVal = !$1.boolVal;
      } |
      Exp AND Exp
      {
            if(!isBoolean($1) || !areEqualTypes($1,$3))
            {
                //output::errorMismatch(yylineno);
                exit(0);
            }
            $$.type = $1.type;
            $$.boolVal = $1.boolVal && $3.boolVal;
      } |
      Exp OR Exp
      {
            if(!isBoolean($1) || !areEqualTypes($1,$3))
            {
                output::errorMismatch(yylineno);
                exit(0);
            }
            $$.type = $1.type;
            $$.boolVal = $1.boolVal || $3.boolVal;
      } |
      Exp RELOP Exp
      {
            if(!isNumeric($1) || !areEqualTypes($1,$3))
            {
                output::errorMismatch(yylineno);
                exit(0);
            }
            $$.type = _BOOL;
      } |
      Exp BINOP Exp
      {
            if(!isNumeric($1) || !isNumeric($3))
            {
                output::errorMismatch(yylineno);
                exit(0);
            }
            $$.type = ($1.type == _BYTE) ? $3.type : $1.type;
      }
    ;

M : { symbolTable->OpenScope();}
    ;

N : {
        if(isWhileOrIfIntact)
        {
            symbolTable->OpenScope();
            isWhileOrIfScopeOpened = true;
        }
        isWhileOrIfIntact = false;
    }
    ;

W : {
        whileCounter++;
        isWhileOrIfIntact = true;
    }
    ;

K : {isWhileOrIfIntact = true;}

%%

int main(){
	symbolTable = new SymbolTable();
	whileCounter = 0;
	isWhileOrIfIntact = false;
	isWhileOrIfScopeOpened = false;
	yyparse();
}

int yyerror(char * message){
	cout<<"Parse error: "<<message<<endl;
	exit(0);
}
